/* This file is part of the Java 1.5 grammar for SableCC.
 *
 * Copyright 2006 Etienne M. Gagnon <egagnon@j-meg.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

Package org.sablecc.grammars.java_1_5;


Helpers

// Note: Helpers have not been verified to exactly match the
// specification.

  unicode_input_character = [0..0xffff];
  ht  = 0x0009;
  lf  = 0x000a;
  ff  = 0x000c;
  cr  = 0x000d;
  sp  = ' ';

  line_terminator = lf | cr | cr lf;
  input_character = [unicode_input_character - [cr + lf]];

  not_star =    [input_character - '*'] | line_terminator;
  not_star_not_slash = [input_character - ['*' + '/']] | line_terminator;

  unicode_letter =
    [0x0041..0x005a] | [0x0061..0x007a] | [0x00aa..0x00aa] | [0x00b5..0x00b5] |
    [0x00ba..0x00ba] | [0x00c0..0x00d6] | [0x00d8..0x00f6] | [0x00f8..0x01f5] |
    [0x01fa..0x0217] | [0x0250..0x02a8] | [0x02b0..0x02b8] | [0x02bb..0x02c1] |
    [0x02d0..0x02d1] | [0x02e0..0x02e4] | [0x037a..0x037a] | [0x0386..0x0386] |
    [0x0388..0x038a] | [0x038c..0x038c] | [0x038e..0x03a1] | [0x03a3..0x03ce] |
    [0x03d0..0x03d6] | [0x03da..0x03da] | [0x03dc..0x03dc] | [0x03de..0x03de] |
    [0x03e0..0x03e0] | [0x03e2..0x03f3] | [0x0401..0x040c] | [0x040e..0x044f] |
    [0x0451..0x045c] | [0x045e..0x0481] | [0x0490..0x04c4] | [0x04c7..0x04c8] |
    [0x04cb..0x04cc] | [0x04d0..0x04eb] | [0x04ee..0x04f5] | [0x04f8..0x04f9] |
    [0x0531..0x0556] | [0x0559..0x0559] | [0x0561..0x0587] | [0x05d0..0x05ea] |
    [0x05f0..0x05f2] | [0x0621..0x063a] | [0x0640..0x064a] | [0x0671..0x06b7] |
    [0x06ba..0x06be] | [0x06c0..0x06ce] | [0x06d0..0x06d3] | [0x06d5..0x06d5] |
    [0x06e5..0x06e6] | [0x0905..0x0939] | [0x093d..0x093d] | [0x0958..0x0961] |
    [0x0985..0x098c] | [0x098f..0x0990] | [0x0993..0x09a8] | [0x09aa..0x09b0] |
    [0x09b2..0x09b2] | [0x09b6..0x09b9] | [0x09dc..0x09dd] | [0x09df..0x09e1] |
    [0x09f0..0x09f1] | [0x0a05..0x0a0a] | [0x0a0f..0x0a10] | [0x0a13..0x0a28] |
    [0x0a2a..0x0a30] | [0x0a32..0x0a33] | [0x0a35..0x0a36] | [0x0a38..0x0a39] |
    [0x0a59..0x0a5c] | [0x0a5e..0x0a5e] | [0x0a72..0x0a74] | [0x0a85..0x0a8b] |
    [0x0a8d..0x0a8d] | [0x0a8f..0x0a91] | [0x0a93..0x0aa8] | [0x0aaa..0x0ab0] |
    [0x0ab2..0x0ab3] | [0x0ab5..0x0ab9] | [0x0abd..0x0abd] | [0x0ae0..0x0ae0] |
    [0x0b05..0x0b0c] | [0x0b0f..0x0b10] | [0x0b13..0x0b28] | [0x0b2a..0x0b30] |
    [0x0b32..0x0b33] | [0x0b36..0x0b39] | [0x0b3d..0x0b3d] | [0x0b5c..0x0b5d] |
    [0x0b5f..0x0b61] | [0x0b85..0x0b8a] | [0x0b8e..0x0b90] | [0x0b92..0x0b95] |
    [0x0b99..0x0b9a] | [0x0b9c..0x0b9c] | [0x0b9e..0x0b9f] | [0x0ba3..0x0ba4] |
    [0x0ba8..0x0baa] | [0x0bae..0x0bb5] | [0x0bb7..0x0bb9] | [0x0c05..0x0c0c] |
    [0x0c0e..0x0c10] | [0x0c12..0x0c28] | [0x0c2a..0x0c33] | [0x0c35..0x0c39] |
    [0x0c60..0x0c61] | [0x0c85..0x0c8c] | [0x0c8e..0x0c90] | [0x0c92..0x0ca8] |
    [0x0caa..0x0cb3] | [0x0cb5..0x0cb9] | [0x0cde..0x0cde] | [0x0ce0..0x0ce1] |
    [0x0d05..0x0d0c] | [0x0d0e..0x0d10] | [0x0d12..0x0d28] | [0x0d2a..0x0d39] |
    [0x0d60..0x0d61] | [0x0e01..0x0e2e] | [0x0e30..0x0e30] | [0x0e32..0x0e33] |
    [0x0e40..0x0e46] | [0x0e81..0x0e82] | [0x0e84..0x0e84] | [0x0e87..0x0e88] |
    [0x0e8a..0x0e8a] | [0x0e8d..0x0e8d] | [0x0e94..0x0e97] | [0x0e99..0x0e9f] |
    [0x0ea1..0x0ea3] | [0x0ea5..0x0ea5] | [0x0ea7..0x0ea7] | [0x0eaa..0x0eab] |
    [0x0ead..0x0eae] | [0x0eb0..0x0eb0] | [0x0eb2..0x0eb3] | [0x0ebd..0x0ebd] |
    [0x0ec0..0x0ec4] | [0x0ec6..0x0ec6] | [0x0edc..0x0edd] | [0x0f40..0x0f47] |
    [0x0f49..0x0f69] | [0x10a0..0x10c5] | [0x10d0..0x10f6] | [0x1100..0x1159] |
    [0x115f..0x11a2] | [0x11a8..0x11f9] | [0x1e00..0x1e9b] | [0x1ea0..0x1ef9] |
    [0x1f00..0x1f15] | [0x1f18..0x1f1d] | [0x1f20..0x1f45] | [0x1f48..0x1f4d] |
    [0x1f50..0x1f57] | [0x1f59..0x1f59] | [0x1f5b..0x1f5b] | [0x1f5d..0x1f5d] |
    [0x1f5f..0x1f7d] | [0x1f80..0x1fb4] | [0x1fb6..0x1fbc] | [0x1fbe..0x1fbe] |
    [0x1fc2..0x1fc4] | [0x1fc6..0x1fcc] | [0x1fd0..0x1fd3] | [0x1fd6..0x1fdb] |
    [0x1fe0..0x1fec] | [0x1ff2..0x1ff4] | [0x1ff6..0x1ffc] | [0x207f..0x207f] |
    [0x2102..0x2102] | [0x2107..0x2107] | [0x210a..0x2113] | [0x2115..0x2115] |
    [0x2118..0x211d] | [0x2124..0x2124] | [0x2126..0x2126] | [0x2128..0x2128] |
    [0x212a..0x2131] | [0x2133..0x2138] | [0x3005..0x3005] | [0x3031..0x3035] |
    [0x3041..0x3094] | [0x309b..0x309e] | [0x30a1..0x30fa] | [0x30fc..0x30fe] |
    [0x3105..0x312c] | [0x3131..0x318e] | [0x4e00..0x9fa5] | [0xac00..0xd7a3] |
    [0xf900..0xfa2d] | [0xfb00..0xfb06] | [0xfb13..0xfb17] | [0xfb1f..0xfb28] |
    [0xfb2a..0xfb36] | [0xfb38..0xfb3c] | [0xfb3e..0xfb3e] | [0xfb40..0xfb41] |
    [0xfb43..0xfb44] | [0xfb46..0xfbb1] | [0xfbd3..0xfd3d] | [0xfd50..0xfd8f] |
    [0xfd92..0xfdc7] | [0xfdf0..0xfdfb] | [0xfe70..0xfe72] | [0xfe74..0xfe74] |
    [0xfe76..0xfefc] | [0xff21..0xff3a] | [0xff41..0xff5a] | [0xff66..0xffbe] |
    [0xffc2..0xffc7] | [0xffca..0xffcf] | [0xffd2..0xffd7] | [0xffda..0xffdc];

  unicode_digit =
    [0x0030..0x0039] | [0x0660..0x0669] | [0x06f0..0x06f9] | [0x0966..0x096f] |
    [0x09e6..0x09ef] | [0x0a66..0x0a6f] | [0x0ae6..0x0aef] | [0x0b66..0x0b6f] |
    [0x0be7..0x0bef] | [0x0c66..0x0c6f] | [0x0ce6..0x0cef] | [0x0d66..0x0d6f] |
    [0x0e50..0x0e59] | [0x0ed0..0x0ed9] | [0x0f20..0x0f29] | [0xff10..0xff19];

  java_letter = unicode_letter | '$' | '_';
  java_letter_or_digit = unicode_letter | unicode_digit | '$' | '_';

  non_zero_digit = ['1'..'9'];
  digit = ['0'..'9'];
  hex_digit = ['0'..'9'] | ['a'..'f'] | ['A'..'F'];
  octal_digit = ['0'..'7'];
  zero_to_three = ['0'..'3'];

  decimal_numeral = '0' | non_zero_digit digit*;
  hex_numeral = '0' ('x' | 'X') hex_digit+;
  octal_numeral = '0' octal_digit+;

  integer_type_suffix = 'l' | 'L';

  exponent_part = ('e' | 'E') ('+' | '-')? digit+;

  float_type_suffix = 'f' | 'F' | 'd' | 'D';

  single_character = [input_character - [''' + '\']];
  octal_escape = '\' (octal_digit octal_digit? | zero_to_three octal_digit octal_digit);
  escape_sequence = '\b' | '\t' | '\n' | '\f' | '\r' | '\"' | '\' ''' | '\\' | octal_escape;
  string_character = [input_character - ['"' + '\']] | escape_sequence;


Tokens

  // separators

  at = '@';
  comma = ',';
  dot   = '.';
  dot_dot_dot = '...';
  l_bkt = '[';
  l_brc = '{';
  l_par = '(';
  r_bkt = ']';
  r_brc = '}';
  r_par = ')';
  semi  = ';';

  // operators

  amp = '&';
  amp_amp = '&&';
  amp_assign = '&=';
  assign = '=';
  bar = '|';
  bar_assign = '|=';
  bar_bar = '||';
  caret = '^';
  caret_assign = '^=';
  colon = ':';
  emark = '!';
  eq = '==';
  gt = '>';
  gteq = '>=';
  lt = '<';
  lteq = '<=';
  minus = '-';
  minus_assign = '-=';
  minus_minus = '--';
  neq = '!=';
  percent = '%';
  percent_assign = '%=';
  plus = '+';
  plus_assign = '+=';
  plus_plus = '++';
  qmark = '?';
  shl = '<<';
  shl_assign = '<<=';
  shr = '>>';
  shr_assign = '>>=';
  slash = '/';
  slash_assign = '/=';
  star = '*';
  star_assign = '*=';
  tilde = '~';
  ushr = '>>>';
  ushr_assign = '>>>=';

  // keywords

  abstract = 'abstract';
  assert = 'assert';
  boolean = 'boolean';
  break = 'break';
  byte = 'byte';
  case = 'case';
  catch = 'catch';
  char = 'char';
  class_token = 'class';
  const = 'const';
  continue = 'continue';
  default = 'default';
  do = 'do';
  double = 'double';
  else = 'else';
  enum = 'enum';
  extends = 'extends';
  false = 'false';
  final = 'final';
  finally_token = 'finally';
  float = 'float';
  for = 'for';
  goto = 'goto';
  if = 'if';
  implements = 'implements';
  import = 'import';
  instanceof = 'instanceof';
  int = 'int';
  interface = 'interface';
  long = 'long';
  native = 'native';
  new = 'new';
  package = 'package';
  private = 'private';
  protected = 'protected';
  public = 'public';
  return = 'return';
  short = 'short';
  static = 'static';
  strictfp = 'strictfp';
  super_token = 'super';
  switch = 'switch';
  synchronized = 'synchronized';
  this = 'this';
  throw = 'throw';
  throws_token = 'throws';
  transient = 'transient';
  true = 'true';
  try = 'try';
  void = 'void';
  volatile = 'volatile';
  while = 'while';

  // literals

  character_literal = ''' (single_character | escape_sequence) ''';

  floating_point_literal =
    digit+ '.' digit* exponent_part? float_type_suffix? |
    '.' digit+ exponent_part? float_type_suffix? |
    digit+ exponent_part float_type_suffix? |
    digit+ exponent_part? float_type_suffix;

  integer_literal =
    decimal_numeral integer_type_suffix? |
    hex_numeral integer_type_suffix? |
    octal_numeral integer_type_suffix?;

  null_literal = 'null';

  string_literal = '"' string_character* '"';

  // identifier

  identifier = java_letter java_letter_or_digit*;

  // white space and comments

  white_space = (sp | ht | ff | line_terminator)*;

  traditional_comment = '/*' not_star+ '*'+ (not_star_not_slash not_star* '*'+)* '/';
  documentation_comment =    '/**' '*'* (not_star_not_slash not_star* '*'+)* '/';
  end_of_line_comment = '//' input_character* line_terminator?;


Ignored Tokens

  white_space,
  traditional_comment,
  documentation_comment,
  end_of_line_comment;


Productions

  compilation_unit =
    package_declaration? [import_declarations]:import_declaration* [type_declarations]:type_declaration*;

  package_declaration =
    [modifiers]:modifier* package identifier [additional_identifiers]:additional_identifier* semi;

  import_declaration =
    {single}        single_type_import_declaration |
    {single_demand} type_import_on_demand_declaration |
    {static}        single_static_import_declaration |
    {static_demand} static_import_on_demand_declaration;

  type_declaration =
    {class}     class_declaration |
    {interface} interface_declaration |
    {empty}     semi;

  annotation =
    {normal_annotation}         normal_annotation |
    {marker_annotation}         marker_annotation |
    {single_element_annotation} single_element_annotation;

  single_type_import_declaration =
    import identifier [additional_identifiers]:additional_identifier* semi;

  type_import_on_demand_declaration =
    import identifier [additional_identifiers]:additional_identifier* dot star semi;

  single_static_import_declaration =
    import static identifier [additional_identifiers]:additional_identifier+ semi;

  static_import_on_demand_declaration =
    import static identifier [additional_identifiers]:additional_identifier* dot star semi;

  class_declaration =
    {normal_class} normal_class_declaration |
    {enum}         enum_declaration;

  interface_declaration =
    {normal_interface} normal_interface_declaration |
    {annotation_type}  annotation_type_declaration;

  normal_annotation =
    at identifier [additional_identifiers]:additional_identifier* l_par element_value_pairs? r_par;

  marker_annotation =
    at identifier [additional_identifiers]:additional_identifier*;

  single_element_annotation =
    at identifier [additional_identifiers]:additional_identifier* l_par element_value r_par;

  normal_class_declaration =
    [modifiers]:modifier* class_token identifier type_parameters? super? interfaces? class_body;

  enum_declaration =
    [modifiers]:modifier* enum identifier interfaces? enum_body;

  normal_interface_declaration =
    [modifiers]:modifier* interface identifier type_parameters? extends_interfaces? interface_body;

  annotation_type_declaration =
    [modifiers]:modifier* at interface identifier annotation_type_body;

  element_value_pairs =
    {one}                            element_value_pair |
    {many} element_value_pairs comma element_value_pair;

  element_value =
    {conditional}       conditional_expression |
    {identifier}        identifier [additional_identifiers]:additional_identifier* |
    {annotation}        annotation |
    {array_initializer} element_value_array_initializer;

  type_parameters =
    {gt}   lt type_parameter_list gt |
    {shr}  lt type_parameter_list_shr shr |
    {ushr} lt type_parameter_list_ushr ushr;

  super =
    extends identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments?;

  interfaces =
    implements interface_type_list;

  class_body =
    l_brc [class_body_declarations]:class_body_declaration* r_brc;

  enum_body =
    l_brc enum_constants? comma? enum_body_declarations? r_brc;

  extends_interfaces =
    {one}  extends                  identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments? |
    {many} extends_interfaces comma identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments?;

  interface_body =
    l_brc [interface_member_declarations]:interface_member_declaration* r_brc;

  annotation_type_body =
    l_brc [annotation_type_element_declarations]:annotation_type_element_declaration* r_brc;

  element_value_pair =
    identifier assign element_value;

  conditional_expression =
    {simple}         conditional_or_expression |
    {qmark_or_ex_or} conditional_or_expression                                                 qmark expression                                                                colon conditional_expression |
    {qmark_or_ex_id} conditional_or_expression                                                 qmark expression                                                                colon               identifier  [additional_identifiers]:additional_identifier* |
    {qmark_or_id_or} conditional_or_expression                                                 qmark               identifier  [additional_identifiers]:additional_identifier* colon conditional_expression |
    {qmakr_or_id_id} conditional_or_expression                                                 qmark [identifier1]:identifier [additional_identifiers1]:additional_identifier* colon [identifier2]:identifier [additional_identifiers2]:additional_identifier* |
    {qmakr_id_ex_or}               identifier  [additional_identifiers]:additional_identifier* qmark expression                                                                colon conditional_expression |
    {qmakr_id_ex_id} [identifier1]:identifier [additional_identifiers1]:additional_identifier* qmark expression                                                                colon [identifier2]:identifier [additional_identifiers2]:additional_identifier* |
    {qmakr_id_id_or} [identifier1]:identifier [additional_identifiers1]:additional_identifier* qmark [identifier2]:identifier [additional_identifiers2]:additional_identifier* colon conditional_expression |
    {qmakr_id_id_id} [identifier1]:identifier [additional_identifiers1]:additional_identifier* qmark [identifier2]:identifier [additional_identifiers2]:additional_identifier* colon [identifier3]:identifier [additional_identifiers3]:additional_identifier*;

  element_value_array_initializer =
    l_brc element_values? comma? r_brc;

  type_parameter_list =
    {one}                            type_parameter |
    {many} type_parameter_list comma type_parameter;

  type_parameter_list_shr =
    {one}                            type_parameter_shr |
    {many} type_parameter_list comma type_parameter_shr;

  type_parameter_list_ushr =
    {one}                            type_parameter_ushr |
    {many} type_parameter_list comma type_parameter_ushr;

  interface_type_list =
    {one}                            identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments? |
    {many} interface_type_list comma identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments?;

  class_body_declaration =
    {member}               class_member_declaration |
    {instance_initializer} instance_initializer |
    {static_initializer}   static_initializer |
    {constructor}          constructor_declaration;

  enum_constants =
    {one}                       enum_constant |
    {many} enum_constants comma enum_constant;

  enum_body_declarations =
    semi [class_body_declarations]:class_body_declaration*;

  interface_member_declaration =
     {constant}  constant_declaration |
     {method}    abstract_method_declaration |
     {class}     class_declaration |
     {interface} interface_declaration |
     {empty}     semi;

  annotation_type_element_declaration =
    {primitive_method} [modifiers]:modifier* primitive_type                                                                                                             [dims]:dim*               identifier l_par r_par default_value? semi |
    {reference_method} [modifiers]:modifier* [identifier1]:identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments? [dims]:dim* [identifier2]:identifier l_par r_par default_value? semi |
    {constant}         constant_declaration |
    {class}            class_declaration |
    {interface}        interface_declaration |
    {empty}            semi;

  conditional_or_expression =
    {simple}                                                                                          conditional_and_expression |
    {bar_bar_or_or} conditional_or_expression                                                 bar_bar conditional_and_expression |
    {bar_bar_or_id} conditional_or_expression                                                 bar_bar               identifier  [additional_identifiers]:additional_identifier* |
    {bar_bar_id_or}               identifier  [additional_identifiers]:additional_identifier* bar_bar conditional_and_expression |
    {bar_bar_id_id} [identifier1]:identifier [additional_identifiers1]:additional_identifier* bar_bar [identifier2]:identifier [additional_identifiers2]:additional_identifier*;

  expression =
    assignment_expression;

  element_values =
    {one}                       element_value |
    {many} element_values comma element_value;

  type_parameter =
    identifier type_bound?;

  type_parameter_shr =
    identifier type_bound_shr;

  type_parameter_ushr =
    identifier type_bound_ushr;

  type_arguments =
    {gt}   lt actual_type_argument_list gt |
    {shr}  lt actual_type_argument_list_shr shr |
    {ushr} lt actual_type_argument_list_ushr ushr;

  type_arguments_shr_no_gt =
    lt actual_type_argument_list;

  type_arguments_ushr_no_gt_gt =
    lt actual_type_argument_list_ushr_no_gt;

  type_arguments_ushr_no_gt =
    lt actual_type_argument_list;

  class_member_declaration =
    {field}     field_declaration |
    {method}    method_declaration |
    {class}     class_declaration |
    {interface} interface_declaration |
    {empty}     semi;

  instance_initializer =
    block;

  static_initializer =
    static block;

  constructor_declaration =
    [modifiers]:modifier* constructor_declarator throws? constructor_body;

  enum_constant =
    [modifiers]:modifier* identifier arguments? class_body?;

  constant_declaration =
    {primitive} [modifiers]:modifier* primitive_type                                                                                               [dims]:dim* variable_declarators semi |
    {reference} [modifiers]:modifier* identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments? [dims]:dim* variable_declarators semi;

  abstract_method_declaration =
    {primitive} [modifiers]:modifier* type_parameters? primitive_type                                                                                               [dims]:dim* method_declarator throws? semi |
    {reference} [modifiers]:modifier* type_parameters? identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments? [dims]:dim* method_declarator throws? semi |
    {void}      [modifiers]:modifier* type_parameters? void                                                                                                                     method_declarator throws? semi;

  default_value =
    default element_value;

  conditional_and_expression =
    {simple}                                                                                          inclusive_or_expression |
    {amp_amp_an_or} conditional_and_expression                                                amp_amp inclusive_or_expression |
    {amp_amp_an_id} conditional_and_expression                                                amp_amp               identifier  [additional_identifiers]:additional_identifier* |
    {amp_amp_id_or}               identifier  [additional_identifiers]:additional_identifier* amp_amp inclusive_or_expression |
    {amp_amp_id_id} [identifier1]:identifier [additional_identifiers1]:additional_identifier* amp_amp [identifier2]:identifier [additional_identifiers2]:additional_identifier*;

  assignment_expression =
    {conditional} conditional_expression |
    {assignment}  assignment;

  type_bound =
    extends identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments? [additional_bounds]:additional_bound*;

  type_bound_shr =
    {argument} extends identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments_shr_no_gt |
    {bound}    extends identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments? [additional_bounds]:additional_bound* additional_bound_shr_no_gt;

  type_bound_ushr =
    {argument} extends identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments_ushr_no_gt_gt |
    {bound}    extends identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments? [additional_bounds]:additional_bound* additional_bound_ushr_no_gt_gt;

  type_component =
    type_arguments [additional_identifiers]:additional_identifier+;

  actual_type_argument_list =
    {one}                                  actual_type_argument |
    {many} actual_type_argument_list comma actual_type_argument;

  actual_type_argument_list_shr =
    {one}                                  actual_type_argument_shr |
    {many} actual_type_argument_list comma actual_type_argument_shr;

  actual_type_argument_list_ushr =
    {one}                                  actual_type_argument_ushr |
    {many} actual_type_argument_list comma actual_type_argument_ushr;

  actual_type_argument_list_ushr_no_gt =
    {one}                                  actual_type_argument_ushr_no_gt |
    {many} actual_type_argument_list comma actual_type_argument_ushr_no_gt;

  field_declaration =
    {primitive} [modifiers]:modifier* primitive_type                                                                                               [dims]:dim* variable_declarators semi |
    {reference} [modifiers]:modifier* identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments? [dims]:dim* variable_declarators semi;

  method_declaration =
    method_header method_body;

  block =
    l_brc [block_statements]:block_statement* r_brc;

  constructor_declarator =
    type_parameters? identifier l_par formal_parameter_list? r_par;

  throws =
    throws_token exception_type_list;

  constructor_body =
    l_brc explicit_constructor_invocation? [block_statements]:block_statement* r_brc;

  arguments =
    l_par argument_list? r_par;

  variable_declarators =
    {one}                             variable_declarator |
    {many} variable_declarators comma variable_declarator;

  method_declarator =
    identifier l_par formal_parameter_list? r_par [dims]:dim*;

  primitive_type =
    {numeric} numeric_type |
    {boolean} boolean;

  inclusive_or_expression =
    {simple}                                                                                  exclusive_or_expression |
    {bar_or_or} inclusive_or_expression                                                   bar exclusive_or_expression |
    {bar_or_id} inclusive_or_expression                                                   bar               identifier  [additional_identifiers]:additional_identifier* |
    {bar_id_or}               identifier  [additional_identifiers]:additional_identifier* bar exclusive_or_expression |
    {bar_id_id} [identifier1]:identifier [additional_identifiers1]:additional_identifier* bar [identifier2]:identifier [additional_identifiers2]:additional_identifier*;

  assignment =
    {expression} left_hand_side assignment_operator assignment_expression |
    {identifier} left_hand_side assignment_operator identifier [additional_identifiers]:additional_identifier*;

  additional_bound =
    amp identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments?;

  additional_bound_shr_no_gt =
    amp identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments_shr_no_gt;

  additional_bound_ushr_no_gt_gt =
    amp identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments_ushr_no_gt_gt;

  actual_type_argument =
    {primitive} primitive_type [dims]:dim+ |
    {reference} identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments? [dims]:dim* |
    {wildcard}  wildcard;

  actual_type_argument_shr =
    {reference} identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments_shr_no_gt |
    {wildcard}  wildcard_shr;

  actual_type_argument_ushr =
    {reference} identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments_ushr_no_gt_gt |
    {wildcard}  wildcard_ushr;

  actual_type_argument_ushr_no_gt =
    {reference} identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments_ushr_no_gt |
    {wildcard}  wildcard_ushr_no_gt;

  method_header =
    {primitive} [modifiers]:modifier* type_parameters? primitive_type                                                                                               [dims]:dim* method_declarator throws? |
    {reference} [modifiers]:modifier* type_parameters? identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments? [dims]:dim* method_declarator throws? |
    {void}      [modifiers]:modifier* type_parameters? void                                                                                                                     method_declarator throws?;

  method_body =
    {block} block |
    {empty} semi;

  block_statement =
    {variable_declaration} local_variable_declaration_statement |
    {class_declaration}    class_declaration |
    {statement}            statement;

  formal_parameter_list =
    {one}                          last_formal_parameter |
    {many} formal_parameters comma last_formal_parameter;

  exception_type_list =
    {one}                            exception_type |
    {many} exception_type_list comma exception_type;

  explicit_constructor_invocation =
    {this}                                                                      non_wild_type_arguments? this        l_par argument_list? r_par semi |
    {super}                                                                     non_wild_type_arguments? super_token l_par argument_list? r_par semi |
    {primary}    primary                                                    dot non_wild_type_arguments? super_token l_par argument_list? r_par semi |
    {identifier} identifier [additional_identifiers]:additional_identifier* dot non_wild_type_arguments? super_token l_par argument_list? r_par semi;

  argument_list =
    {one_ex}                      expression |
    {one_id}                      identifier [additional_identifiers]:additional_identifier* |
    {many_ex} argument_list comma expression |
    {many_id} argument_list comma identifier [additional_identifiers]:additional_identifier*;

  variable_declarator =
    {simple}      identifier [dims]:dim* |
    {initializer} identifier [dims]:dim* assign variable_initializer;

  numeric_type =
    {integral} integral_type |
    {floating} floating_point_type;

  exclusive_or_expression =
    {simple}                                                                                      and_expression |
    {caret_or_an} exclusive_or_expression                                                   caret and_expression |
    {caret_or_id} exclusive_or_expression                                                   caret               identifier  [additional_identifiers]:additional_identifier* |
    {caret_id_an}               identifier  [additional_identifiers]:additional_identifier* caret and_expression |
    {caret_id_id} [identifier1]:identifier [additional_identifiers1]:additional_identifier* caret [identifier2]:identifier [additional_identifiers2]:additional_identifier*;

  left_hand_side =
    {identifier} identifier [additional_identifiers]:additional_identifier* |
    {field}      field_access |
    {array}      array_access;

  assignment_operator =
    {assign}         assign |
    {star_assign}    star_assign |
    {slash_assign}   slash_assign |
    {percent_assign} percent_assign |
    {plus_assign}    plus_assign |
    {minus_assign}   minus_assign |
    {shl_assign}     shl_assign |
    {shr_assign}     shr_assign |
    {ushr_assign}    ushr_assign |
    {amp_assign}     amp_assign |
    {caret_assign}   caret_assign |
    {bar_assign}     bar_assign;

  wildcard =
    qmark wildcard_bounds?;

  wildcard_shr =
    qmark wildcard_bounds_shr;

  wildcard_ushr =
    qmark wildcard_bounds_ushr;

  wildcard_ushr_no_gt =
    qmark wildcard_bounds_ushr_no_gt;

  local_variable_declaration_statement =
    local_variable_declaration semi;

  statement =
    {no_trail}   statement_without_trailing_substatement |
    {label}      labeled_statement |
    {if}         if_then_statement |
    {if_else}    if_then_else_statement |
    {while_loop} while_statement |
    {for_loop}   for_statement;

  last_formal_parameter =
    {primitive_var_arg} [modifiers]:modifier* primitive_type                                                                                                             [dims1]:dim* dot_dot_dot               identifier [dims2]:dim* |
    {reference_var_arg} [modifiers]:modifier* [identifier1]:identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments? [dims1]:dim* dot_dot_dot [identifier2]:identifier [dims2]:dim* |
    {simple}            formal_parameter;

  formal_parameters =
    {one}                          formal_parameter |
    {many} formal_parameters comma formal_parameter;

  exception_type =
    identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments?;

  non_wild_type_arguments =
    {gt}   lt reference_type_list gt |
    {shr}  lt reference_type_list_shr shr |
    {ushr} lt reference_type_list_ushr ushr;

  primary =
    {no_array} primary_no_new_array |
    {array}    array_creation_expression;

  variable_initializer =
    {expression} expression |
    {identifier} identifier [additional_identifiers]:additional_identifier* |
    {array}      array_initializer;

  integral_type =
    {byte}  byte |
    {short} short |
    {int}   int |
    {long}  long |
    {char}  char;

  floating_point_type =
    {float}  float |
    {double} double;

  and_expression =
    {simple}                                                                                  equality_expression |
    {amp_an_eq} and_expression                                                            amp equality_expression |
    {amp_an_id} and_expression                                                            amp               identifier  [additional_identifiers]:additional_identifier* |
    {amp_id_eq}               identifier  [additional_identifiers]:additional_identifier* amp equality_expression |
    {amp_id_id} [identifier1]:identifier [additional_identifiers1]:additional_identifier* amp [identifier2]:identifier [additional_identifiers2]:additional_identifier*;

  field_access =
    {primary}                                                                                             primary            dot               identifier |
    {super}                                                                                               super_token        dot               identifier |
    {reference_super} [identifier1]:identifier [additional_identifiers]:additional_identifier* [dot1]:dot super_token [dot2]:dot [identifier2]:identifier;

  array_access =
    {primary_ex}    primary_no_new_array                                                      l_bkt expression                                                                r_bkt |
    {primary_id}    primary_no_new_array                                                      l_bkt               identifier  [additional_identifiers]:additional_identifier* r_bkt |
    {identifier_ex}               identifier  [additional_identifiers]:additional_identifier* l_bkt expression                                                                r_bkt |
    {identifier_id} [identifier1]:identifier [additional_identifiers1]:additional_identifier* l_bkt [identifier2]:identifier [additional_identifiers2]:additional_identifier* r_bkt;

  wildcard_bounds =
    {extends_primitive} extends     primitive_type [dims]:dim+ |
    {extends_reference} extends     identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments? [dims]:dim* |
    {super_primitive}   super_token primitive_type [dims]:dim+ |
    {super_reference}   super_token identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments? [dims]:dim*;

  wildcard_bounds_shr =
    {extends_reference} extends     identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments_shr_no_gt |
    {super_reference}   super_token identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments_shr_no_gt;

  wildcard_bounds_ushr =
    {extends_reference} extends     identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments_ushr_no_gt_gt |
    {super_reference}   super_token identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments_ushr_no_gt_gt;

  wildcard_bounds_ushr_no_gt =
    {extends_reference} extends     identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments_ushr_no_gt |
    {super_reference}   super_token identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments_ushr_no_gt;

  local_variable_declaration =
    {primitive} [modifiers]:modifier* primitive_type                                                                                               [dims]:dim* variable_declarators |
    {reference} [modifiers]:modifier* identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments? [dims]:dim* variable_declarators;

  statement_without_trailing_substatement =
    {block}                  block |
    {empty_statement}        empty_statement |
    {expression_statement}   expression_statement |
    {assert_statement}       assert_statement |
    {switch_statement}       switch_statement |
    {do_statement}           do_statement |
    {break_statement}        break_statement |
    {continue_statement}     continue_statement |
    {return_statement}       return_statement |
    {synchronized_statement} synchronized_statement |
    {throw_statement}        throw_statement |
    {try_statement}          try_statement;

  labeled_statement =
    identifier colon statement;

  if_then_statement =
    {expression} if l_par expression                                                 r_par statement |
    {identifier} if l_par identifier [additional_identifiers]:additional_identifier* r_par statement;

  if_then_else_statement =
    {expression} if l_par expression                                                 r_par statement_no_short_if else statement |
    {identifier} if l_par identifier [additional_identifiers]:additional_identifier* r_par statement_no_short_if else statement;

  while_statement =
    {expression} while l_par expression                                                 r_par statement |
    {identifier} while l_par identifier [additional_identifiers]:additional_identifier* r_par statement;

  for_statement =
    {basic_for}    basic_for_statement |
    {enhanced_for} enhanced_for_statement;

  formal_parameter =
    {primitive} [modifiers]:modifier* primitive_type                                                                                                             [dims1]:dim*               identifier [dims2]:dim* |
    {reference} [modifiers]:modifier* [identifier1]:identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments? [dims1]:dim* [identifier2]:identifier [dims2]:dim*;

  reference_type_list =
    {one_primitive}                            primitive_type [dims]:dim+ |
    {one_reference}                            identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments? [dims]:dim* |
    {many_primitive} reference_type_list comma primitive_type [dims]:dim+ |
    {many_reference} reference_type_list comma identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments? [dims]:dim*;

  reference_type_list_shr =
    {one_reference}                            identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments_shr_no_gt |
    {many_reference} reference_type_list comma identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments_shr_no_gt;

  reference_type_list_ushr =
    {one_reference}                            identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments_ushr_no_gt_gt |
    {many_reference} reference_type_list comma identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments_ushr_no_gt_gt;

  primary_no_new_array =
    {literal}    literal |
    {primitive}  primitive_type                                             [dims]:dim* dot class_token |
    {reference}  identifier [additional_identifiers]:additional_identifier* [dims]:dim* dot class_token |
    {void}       void dot class_token |
    {this}       this |
    {class}      identifier [additional_identifiers]:additional_identifier* dot this |
    {expression} l_par expression                                                 r_par |
    {identifier} l_par identifier [additional_identifiers]:additional_identifier* r_par |
    {instance}   class_instance_creation_expression |
    {field}      field_access |
    {method}     method_invocation |
    {array}      array_access;

  array_creation_expression =
    {primitive}             new primitive_type                                                                                               [dim_exprs]:dim_expr+ [dims]:dim* |
    {reference}             new identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments? [dim_exprs]:dim_expr+ [dims]:dim* |
    {primitive_initializer} new primitive_type                                                                                               [dims]:dim+ array_initializer |
    {reference_initializer} new identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments? [dims]:dim+ array_initializer;

  array_initializer =
    l_brc variable_initializers? comma? r_brc;

  variable_initializers =
    {one}                              variable_initializer |
    {many} variable_initializers comma variable_initializer;

  equality_expression =
    {simple}                                                                                  relational_expression |
    {eq_eq_re}  equality_expression                                                       eq  relational_expression |
    {eq_eq_id}  equality_expression                                                       eq                identifier  [additional_identifiers]:additional_identifier* |
    {eq_id_re}                identifier  [additional_identifiers]:additional_identifier* eq  relational_expression |
    {eq_id_id}  [identifier1]:identifier [additional_identifiers1]:additional_identifier* eq  [identifier2]:identifier [additional_identifiers2]:additional_identifier* |
    {neq_eq_re} equality_expression                                                       neq relational_expression |
    {neq_eq_id} equality_expression                                                       neq               identifier  [additional_identifiers]:additional_identifier* |
    {neq_id_re}               identifier  [additional_identifiers]:additional_identifier* neq relational_expression |
    {neq_id_id} [identifier1]:identifier [additional_identifiers1]:additional_identifier* neq [identifier2]:identifier [additional_identifiers2]:additional_identifier*;

  empty_statement =
    semi;

  expression_statement =
    statement_expression semi;

  assert_statement =
    {one_ex}    assert               expression                                                  semi |
    {one_id}    assert               identifier [additional_identifiers]:additional_identifier*  semi |
    {two_ex_ex} assert [expression1]:expression                                                  colon [expression2]:expression semi |
    {two_ex_id} assert               expression                                                  colon               identifier  [additional_identifiers]:additional_identifier* semi |
    {two_id_ex} assert               identifier  [additional_identifiers]:additional_identifier* colon expression                                                                semi |
    {two_id_id} assert [identifier1]:identifier [additional_identifiers1]:additional_identifier* colon [identifier2]:identifier [additional_identifiers2]:additional_identifier* semi;

  switch_statement =
    {expression} switch l_par expression                                                 r_par switch_block |
    {identifier} switch l_par identifier [additional_identifiers]:additional_identifier* r_par switch_block;

  do_statement =
    {expression} do statement while l_par expression                                                 r_par semi |
    {identifier} do statement while l_par identifier [additional_identifiers]:additional_identifier* r_par semi;

  break_statement =
    break identifier? semi;

  continue_statement =
    continue identifier? semi;

  return_statement =
    {empty}      return                                                            semi |
    {expression} return expression                                                 semi |
    {identifier} return identifier [additional_identifiers]:additional_identifier* semi;

  synchronized_statement =
    {expression} synchronized l_par expression                                                 r_par block |
    {identifier} synchronized l_par identifier [additional_identifiers]:additional_identifier* r_par block;

  throw_statement =
    {expression} throw expression                                                 semi |
    {identifier} throw identifier [additional_identifiers]:additional_identifier* semi;

  try_statement =
    {catch}   try block [catch_clauses]:catch_clause+ |
    {finally} try block [catch_clauses]:catch_clause* finally;

  statement_no_short_if =
    {statement_without_trailing_substatement} statement_without_trailing_substatement |
    {labeled_statement_no_short_if}           labeled_statement_no_short_if |
    {if_then_else_statement_no_short_if}      if_then_else_statement_no_short_if |
    {while_statement_no_short_if}             while_statement_no_short_if |
    {for_statement_no_short_if}               for_statement_no_short_if;

  basic_for_statement =
    {empty}      for l_par for_init? [semi1]:semi                                                            [semi2]:semi for_update? r_par statement |
    {expression} for l_par for_init? [semi1]:semi expression                                                 [semi2]:semi for_update? r_par statement |
    {identifier} for l_par for_init? [semi1]:semi identifier [additional_identifiers]:additional_identifier* [semi2]:semi for_update? r_par statement;

  enhanced_for_statement =
    {primitive_expression} for l_par [modifiers]:modifier* primitive_type                                                                                                              [dims]:dim*               identifier colon expression                                                                r_par statement |
    {primitive_identifier} for l_par [modifiers]:modifier* primitive_type                                                                                                              [dims]:dim* [identifier1]:identifier colon [identifier2]:identifier  [additional_identifiers]:additional_identifier* r_par statement |
    {reference_expression} for l_par [modifiers]:modifier* [identifier1]:identifier  [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments? [dims]:dim* [identifier2]:identifier colon expression                                                                r_par statement |
    {reference_identifier} for l_par [modifiers]:modifier* [identifier1]:identifier [additional_identifiers1]:additional_identifier* [type_components]:type_component* type_arguments? [dims]:dim* [identifier2]:identifier colon [identifier3]:identifier [additional_identifiers2]:additional_identifier* r_par statement;

  literal =
    {integer}        integer_literal |
    {floating_point} floating_point_literal |
    {boolean}        boolean_literal |
    {character}      character_literal |
    {string}         string_literal |
    {null}           null_literal;

  class_instance_creation_expression =
    {simple}                                                                                  new [type_arguments1]:type_arguments?               identifier [additional_identifiers]:additional_identifier* [type_components]:type_component* [type_arguments2]:type_arguments? l_par argument_list? r_par class_body? |
    {primary}    primary                                                                  dot new [type_arguments1]:type_arguments?               identifier                                                                                   [type_arguments2]:type_arguments? l_par argument_list? r_par class_body? |
    {identifier} [identifier1]:identifier [additional_identifiers]:additional_identifier* dot new [type_arguments1]:type_arguments? [identifier2]:identifier                                                                                   [type_arguments2]:type_arguments? l_par argument_list? r_par class_body?;

  method_invocation =
    {simple}                   identifier [additional_identifiers]:additional_identifier*                                                                                     l_par argument_list? r_par |
    {primary}    primary     dot non_wild_type_arguments? identifier                                                                                                          l_par argument_list? r_par |
    {super}      super_token dot non_wild_type_arguments? identifier                                                                                                          l_par argument_list? r_par |
    {class_name} [identifier1]:identifier [additional_identifiers]:additional_identifier* [dot1]:dot super_token [dot2]:dot non_wild_type_arguments? [identifier2]:identifier l_par argument_list? r_par |
    {type_name}  [identifier1]:identifier [additional_identifiers]:additional_identifier*                               dot non_wild_type_arguments  [identifier2]:identifier l_par argument_list? r_par;

  dim_expr =
    {expression} l_bkt expression                                                 r_bkt |
    {identifier} l_bkt identifier [additional_identifiers]:additional_identifier* r_bkt;

  dim =
    l_bkt r_bkt;

  relational_expression =
    {simple}                                                                                                                     shift_expression |
    {lt_sh_sh}                [shift_expression1]:shift_expression                                      lt   [shift_expression2]:shift_expression |
    {lt_sh_id}                                    shift_expression                                      lt                 identifier  [additional_identifiers]:additional_identifier* |
    {lt_id_sh}                              identifier  [additional_identifiers]:additional_identifier* lt                       shift_expression |
    {lt_id_id}                [identifier1]:identifier [additional_identifiers1]:additional_identifier* lt   [identifier2]:identifier [additional_identifiers2]:additional_identifier* |
    {gt_sh_sh}                [shift_expression1]:shift_expression                                      gt   [shift_expression2]:shift_expression |
    {gt_sh_id}                                    shift_expression                                      gt                 identifier  [additional_identifiers]:additional_identifier* |
    {gt_id_sh}                              identifier  [additional_identifiers]:additional_identifier* gt                       shift_expression |
    {gt_id_id}                [identifier1]:identifier [additional_identifiers1]:additional_identifier* gt   [identifier2]:identifier [additional_identifiers2]:additional_identifier* |
    {lteq_sh_sh}              [shift_expression1]:shift_expression                                      lteq [shift_expression2]:shift_expression |
    {lteq_sh_id}                                  shift_expression                                      lteq               identifier  [additional_identifiers]:additional_identifier* |
    {lteq_id_sh}                            identifier  [additional_identifiers]:additional_identifier* lteq                     shift_expression |
    {lteq_id_id}              [identifier1]:identifier [additional_identifiers1]:additional_identifier* lteq [identifier2]:identifier [additional_identifiers2]:additional_identifier* |
    {gteq_sh_sh}              [shift_expression1]:shift_expression                                      gteq [shift_expression2]:shift_expression |
    {gteq_sh_id}                                  shift_expression                                      gteq               identifier  [additional_identifiers]:additional_identifier* |
    {gteq_id_sh}                            identifier  [additional_identifiers]:additional_identifier* gteq                     shift_expression |
    {gteq_id_id}              [identifier1]:identifier [additional_identifiers1]:additional_identifier* gteq [identifier2]:identifier [additional_identifiers2]:additional_identifier* |
    {instanceof_sh_primitive} shift_expression                                                          instanceof primitive_type [dims]:dim+ |
    {instanceof_sh_reference} shift_expression                                                          instanceof               identifier  [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments? [dims]:dim* |
    {instanceof_id_primitive}               identifier  [additional_identifiers]:additional_identifier* instanceof primitive_type [dims]:dim+ |
    {instanceof_id_reference} [identifier1]:identifier [additional_identifiers1]:additional_identifier* instanceof [identifier2]:identifier [additional_identifiers2]:additional_identifier* [type_components]:type_component* type_arguments? [dims]:dim*;

  statement_expression =
    {assignment}        assignment |
    {pre_increment}     pre_increment_expression |
    {pre_decrement}     pre_decrement_expression |
    {post_increment}    post_increment_expression |
    {post_decrement}    post_decrement_expression |
    {method_invocation} method_invocation |
    {instance_creation} class_instance_creation_expression;

  switch_block =
    l_brc [switch_block_statement_groups]:switch_block_statement_group* [switch_labels]:switch_label* r_brc;

  catch_clause =
    catch l_par formal_parameter r_par block;

  finally =
    finally_token block;

  labeled_statement_no_short_if =
    identifier colon statement_no_short_if;

  if_then_else_statement_no_short_if =
    {expression} if l_par expression                                                 r_par [statement_no_short_if1]:statement_no_short_if else [statement_no_short_if2]:statement_no_short_if |
    {identifier} if l_par identifier [additional_identifiers]:additional_identifier* r_par [statement_no_short_if1]:statement_no_short_if else [statement_no_short_if2]:statement_no_short_if;

  while_statement_no_short_if =
    {expression} while l_par expression                                                 r_par statement_no_short_if |
    {identifier} while l_par identifier [additional_identifiers]:additional_identifier* r_par statement_no_short_if;

  for_statement_no_short_if =
    {empty}      for l_par for_init? [semi1]:semi                                                            [semi2]:semi for_update? r_par statement_no_short_if |
    {expression} for l_par for_init? [semi1]:semi expression                                                 [semi2]:semi for_update? r_par statement_no_short_if |
    {identifier} for l_par for_init? [semi1]:semi identifier [additional_identifiers]:additional_identifier* [semi2]:semi for_update? r_par statement_no_short_if;

  for_init =
    {statement}            statement_expression_list |
    {variable_declaration} local_variable_declaration;

  for_update =
    statement_expression_list;

  shift_expression =
    {simple}                                                                                    additive_expression |
    {shl_sh_ad}  shift_expression                                                          shl  additive_expression |
    {shl_sh_id}  shift_expression                                                          shl                identifier  [additional_identifiers]:additional_identifier* |
    {shl_id_ad}                identifier  [additional_identifiers]:additional_identifier* shl  additive_expression |
    {shl_id_id}  [identifier1]:identifier [additional_identifiers1]:additional_identifier* shl  [identifier2]:identifier [additional_identifiers2]:additional_identifier* |
    {shr_sh_ad}  shift_expression                                                          shr  additive_expression |
    {shr_sh_id}  shift_expression                                                          shr                identifier  [additional_identifiers]:additional_identifier* |
    {shr_id_ad}                identifier  [additional_identifiers]:additional_identifier* shr  additive_expression |
    {shr_id_id}  [identifier1]:identifier [additional_identifiers1]:additional_identifier* shr  [identifier2]:identifier [additional_identifiers2]:additional_identifier* |
    {ushr_sh_ad} shift_expression                                                          ushr additive_expression |
    {ushr_sh_id} shift_expression                                                          ushr               identifier  [additional_identifiers]:additional_identifier* |
    {ushr_id_ad}               identifier  [additional_identifiers]:additional_identifier* ushr additive_expression |
    {ushr_id_id} [identifier1]:identifier [additional_identifiers1]:additional_identifier* ushr [identifier2]:identifier [additional_identifiers2]:additional_identifier*;

  pre_increment_expression =
    {expression} plus_plus unary_expression |
    {identifier} plus_plus identifier [additional_identifiers]:additional_identifier*;

  pre_decrement_expression =
    {expression} minus_minus unary_expression |
    {identifier} minus_minus identifier [additional_identifiers]:additional_identifier*;

  post_increment_expression =
    {expression} postfix_expression                                         plus_plus |
    {identifier} identifier [additional_identifiers]:additional_identifier* plus_plus;

  post_decrement_expression =
    {expression} postfix_expression                                         minus_minus |
    {identifier} identifier [additional_identifiers]:additional_identifier* minus_minus;

  switch_block_statement_group =
    [switch_labels]:switch_label+ [block_statements]:block_statement+;

  switch_label =
    {expression} case constant_expression                                        colon |
    {identifier} case identifier [additional_identifiers]:additional_identifier* colon |
    {default}    default                                                         colon;

  statement_expression_list =
    {one}                                  statement_expression |
    {many} statement_expression_list comma statement_expression;

  additive_expression =
    {simple}                                                                                       multiplicative_expression |
    {plus_ad_mu}   additive_expression                                                       plus  multiplicative_expression |
    {plus_ad_id}   additive_expression                                                       plus                identifier  [additional_identifiers]:additional_identifier* |
    {plus_id_mu}                 identifier  [additional_identifiers]:additional_identifier* plus  multiplicative_expression |
    {plus_id_id}   [identifier1]:identifier [additional_identifiers1]:additional_identifier* plus  [identifier2]:identifier [additional_identifiers2]:additional_identifier* |
    {minus_ad_mu}  additive_expression                                                       minus multiplicative_expression |
    {minus_ad_id}  additive_expression                                                       minus               identifier  [additional_identifiers]:additional_identifier* |
    {minus_id_mu}                identifier  [additional_identifiers]:additional_identifier* minus multiplicative_expression |
    {minus_id_id}  [identifier1]:identifier [additional_identifiers1]:additional_identifier* minus [identifier2]:identifier [additional_identifiers2]:additional_identifier*;

  unary_expression =
   {pre_increment}    pre_increment_expression |
   {pre_decrement}    pre_decrement_expression |
   {plus_expression}  plus  unary_expression |
   {plus_identifier}  plus  identifier [additional_identifiers]:additional_identifier* |
   {minus_expression} minus unary_expression |
   {minus_identifier} minus identifier [additional_identifiers]:additional_identifier* |
   {unary}            unary_expression_not_plus_minus;

  postfix_expression =
    {primary}        primary |
    {post_increment} post_increment_expression |
    {post_decrement} post_decrement_expression;

  constant_expression =
    expression;

  multiplicative_expression =
    {simple}                                                                                          unary_expression |
    {star_mu_un}    multiplicative_expression                                                 star    unary_expression |
    {star_mu_id}    multiplicative_expression                                                 star                  identifier  [additional_identifiers]:additional_identifier* |
    {star_id_un}                  identifier  [additional_identifiers]:additional_identifier* star    unary_expression |
    {star_id_id}    [identifier1]:identifier [additional_identifiers1]:additional_identifier* star    [identifier2]:identifier [additional_identifiers2]:additional_identifier* |
    {slash_mu_un}   multiplicative_expression                                                 slash   unary_expression |
    {slash_mu_id}   multiplicative_expression                                                 slash                 identifier  [additional_identifiers]:additional_identifier* |
    {slash_id_un}                 identifier  [additional_identifiers]:additional_identifier* slash   unary_expression |
    {slash_id_id}   [identifier1]:identifier [additional_identifiers1]:additional_identifier* slash   [identifier2]:identifier [additional_identifiers2]:additional_identifier* |
    {percent_mu_un} multiplicative_expression                                                 percent unary_expression |
    {percent_mu_id} multiplicative_expression                                                 percent               identifier  [additional_identifiers]:additional_identifier* |
    {percent_id_un}               identifier  [additional_identifiers]:additional_identifier* percent unary_expression |
    {percent_id_id} [identifier1]:identifier [additional_identifiers1]:additional_identifier* percent [identifier2]:identifier [additional_identifiers2]:additional_identifier*;

  unary_expression_not_plus_minus =
    {postfix}          postfix_expression |
    {tilde_expression} tilde unary_expression |
    {tilde_identifier} tilde identifier [additional_identifiers]:additional_identifier* |
    {emark_expression} emark unary_expression |
    {emark_identifier} emark identifier [additional_identifiers]:additional_identifier* |
    {cast}             cast_expression;

  cast_expression =
    {primitive_expression} l_par primitive_type                                                                                                              [dims]:dim* r_par unary_expression |
    {primitive_identifier} l_par primitive_type                                                                                                              [dims]:dim* r_par               identifier  [additional_identifiers]:additional_identifier* |
    {reference_expression} l_par               identifier  [additional_identifiers]:additional_identifier* [type_components]:type_component* type_arguments? [dims]:dim* r_par unary_expression_not_plus_minus |
    {reference_identifier} l_par [identifier1]:identifier [additional_identifiers1]:additional_identifier* [type_components]:type_component* type_arguments? [dims]:dim* r_par [identifier2]:identifier [additional_identifiers2]:additional_identifier*;

  modifier =
    {abstract}     abstract |
    {annotation}   annotation |
    {final}        final |
    {native}       native |
    {private}      private |
    {protected}    protected |
    {public}       public |
    {static}       static |
    {strictfp}     strictfp |
    {synchronized} synchronized |
    {transient}    transient |
    {volatile}     volatile;

  additional_identifier =
    dot identifier;

  boolean_literal =
    {true}  true |
    {false} false;
